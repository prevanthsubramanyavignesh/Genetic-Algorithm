#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define POPULATION_SIZE 25
#define GENE_LENGTH 10
#define NUM_GENERATIONS 25
#define MUTATION_PROBABILITY 0.05

// Struct to represent an individual
typedef struct {
    int genes[GENE_LENGTH];
    int fitness;
} Individual;

// Function to calculate fitness (sum of genes)
void compute_fitness(Individual* individual) {
    individual->fitness = 0;
    for (int i = 0; i < GENE_LENGTH; i++) {
        individual->fitness += individual->genes[i];
    }
}

// Function to create a random individual
Individual generate_individual() {
    Individual individual;
    for (int i = 0; i < GENE_LENGTH; i++) {
        individual.genes[i] = rand() % 2;  // Random 0 or 1
    }
    compute_fitness(&individual);
    return individual;
}

// Function to perform roulette wheel selection
Individual roulette_wheel_selection(Individual population[], int total_fitness) {
    int selection_point = rand() % total_fitness;
    int cumulative_fitness = 0;
    for (int i = 0; i < POPULATION_SIZE; i++) {
        cumulative_fitness += population[i].fitness;
        if (cumulative_fitness > selection_point) {
            return population[i];
        }
    }
    return population[0];  // Default return in case something goes wrong
}

// Single-point crossover function
void crossover(Individual* parent1, Individual* parent2, Individual* child1, Individual* child2) {
    int crossover_point = rand() % (GENE_LENGTH - 1) + 1;  // Crossover point

    for (int i = 0; i < crossover_point; i++) {
        child1->genes[i] = parent1->genes[i];
        child2->genes[i] = parent2->genes[i];
    }
    for (int i = crossover_point; i < GENE_LENGTH; i++) {
        child1->genes[i] = parent2->genes[i];
        child2->genes[i] = parent1->genes[i];
    }

    // Recalculate fitness for children
    compute_fitness(child1);
    compute_fitness(child2);
}

// Mutation function
void mutate(Individual* individual) {
    for (int i = 0; i < GENE_LENGTH; i++) {
        if ((double)rand() / RAND_MAX < MUTATION_PROBABILITY) {
            individual->genes[i] = 1 - individual->genes[i];  // Flip bit
        }
    }
    compute_fitness(individual);  // Recalculate fitness after mutation
}

// Function to find the best individual in the population
Individual find_best_individual(Individual population[]) {
    Individual best_individual = population[0];
    for (int i = 1; i < POPULATION_SIZE; i++) {
        if (population[i].fitness > best_individual.fitness) {
            best_individual = population[i];
        }
    }
    return best_individual;
}

// Main Genetic Algorithm function
void genetic_algorithm() {
    Individual population[POPULATION_SIZE];
    Individual new_population[POPULATION_SIZE];
    int total_fitness;

    // Initialize population
    for (int i = 0; i < POPULATION_SIZE; i++) {
        population[i] = generate_individual();
    }

    // Main loop: evolve population over generations
    for (int generation = 0; generation < NUM_GENERATIONS; generation++) {
        // Calculate total fitness for the current population
        total_fitness = 0;
        for (int i = 0; i < POPULATION_SIZE; i++) {
            total_fitness += population[i].fitness;
        }

        // Get the best individual in the current generation
        Individual best_individual = find_best_individual(population);
        printf("Generation %d: Best Fitness = %d\n", generation + 1, best_individual.fitness);

        // Create new population
        for (int i = 0; i < POPULATION_SIZE; i += 2) {
            // Selection
            Individual parent1 = roulette_wheel_selection(population, total_fitness);
            Individual parent2 = roulette_wheel_selection(population, total_fitness);

            // Crossover
            crossover(&parent1, &parent2, &new_population[i], &new_population[i + 1]);

            // Mutate children
            mutate(&new_population[i]);
            mutate(&new_population[i + 1]);
        }

        // Replace old population with new one
        for (int i = 0; i < POPULATION_SIZE; i++) {
            population[i] = new_population[i];
        }
    }

    // Get the best individual in the final population
    Individual best_individual = find_best_individual(population);
    printf("Best solution found: [");
    for (int i = 0; i < GENE_LENGTH; i++) {
        printf("%d", best_individual.genes[i]);
        if (i < GENE_LENGTH - 1) printf(", ");
    }
    printf("] with fitness = %d\n", best_individual.fitness);
}

int main() {
    srand(time(0));  // Seed the random number generator
    genetic_algorithm();
    return 0;
}
